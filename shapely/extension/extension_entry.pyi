from typing import Dict

from shapely.extension.model.aggregation import Aggregation as Aggregation
from shapely.extension.model.alignment import BaseAlignGeom as BaseAlignGeom, \
    BaseAlignMultiPartGeom as BaseAlignMultiPartGeom
from shapely.extension.model.envelope import EnvelopeCreator as EnvelopeCreator
from shapely.extension.model.projection import ProjectionTowards as ProjectionTowards
from shapely.extension.model.stretch import Stretch as Stretch
from shapely.extension.predicator.alignment_predicator_creator import \
    AlignmentPredicatorCreator as AlignmentPredicatorCreator
from shapely.extension.predicator.angle_predicator_creator import AnglePredicatorCreator as AnglePredicatorCreator
from shapely.extension.predicator.distance_predicator_creator import \
    DistancePredicatorCreator as DistancePredicatorCreator
from shapely.extension.predicator.relation_predicator_creator import \
    RelationPredicatorCreator as RelationPredicatorCreator
from shapely.extension.strategy.angle_strategy import AngleStrategyType as AngleStrategyType
from shapely.extension.strategy.simplify_strategy import BaseSimplifyStrategy as BaseSimplifyStrategy
from shapely.geometry import MultiLineString as MultiLineString


class BaseGeomExtension:
    def __init__(self, geom) -> None: ...

    @property
    def cargo(self) -> Dict: ...

    def stretch(self) -> Stretch: ...

    def decompose(self, target_class: type, strategy: Optional[BaseDecomposeStrategy] = ...) -> Aggregation: ...

    def flatten(self, target_class_or_callable: Union[type, Tuple[type], Callable[[BaseGeometry], bool], None] = ...,
                validate: bool = ..., filter_valid: bool = ..., filter_out_empty: bool = ...) -> Aggregation: ...

    def envelope(self) -> EnvelopeCreator: ...

    def divided_by(self, line_or_lines: Union[LineString, Iterable[LineString], MultiLineString],
                   dist_tol: Num = ...) -> Aggregation: ...

    def move_by(self, vector: Vector): ...

    def move_to(self, point_or_coord: Union[CoordType, Point], origin: Union[str, Point, CoordType] = ...): ...

    def rotate_ccw(self, angle: float): ...

    def scale(self, x_ratio: float = ..., y_ratio: float = ...): ...

    def ccw(self): ...

    def connect_path(self, geom: BaseGeometry, direction: Optional[Vector] = ...) -> LineString: ...

    def difference(self, geom_or_geoms: Union[BaseGeometry, Iterable[BaseGeometry]], self_buffer: Num = ...,
                   component_buffer: Num = ...): ...

    def intersection(self, geom_or_geoms: Union[BaseGeometry, Iterable[BaseGeometry]], self_buffer: Num = ...,
                     component_buffer: Num = ...): ...

    def is_(self, *conditions: Iterable[str]) -> bool: ...

    def angle(self, strategy: Optional[AngleStrategyType] = ...) -> Angle: ...

    def simplify(self, strategy: Optional[BaseSimplifyStrategy] = ...): ...

    def move_towards(self, geom: BaseGeometry, direction: Optional[Vector] = ..., util: Optional = ...): ...

    def projection_towards(self, poly: Polygon, direction: Vector) -> ProjectionTowards: ...

    def distance(self, geom: BaseGeometry, direction: Optional[Vector] = ...) -> float: ...

    def alignment(self, direction_dist_tol: Num = ..., angle_tol: Num = ...) -> Union[
        BaseAlignMultiPartGeom, BaseAlignGeom]: ...

    def f_distance(self) -> DistancePredicatorCreator: ...

    def f_relation(self) -> RelationPredicatorCreator: ...

    def f_alignment(self, direction: Optional[Vector] = ..., direction_dist_tol: Num = ...,
                    angle_tol: Num = ...) -> AlignmentPredicatorCreator: ...

    def f_angle(self, strategy: Optional[Callable[[BaseGeometry], Num]] = ...) -> AnglePredicatorCreator: ...

    def almost_intersects(self, geom_or_geoms: Union[BaseGeometry, Iterable[BaseGeometry]],
                          dist_tol: Num = ...) -> bool: ...


from shapely.extension.extension.base_geom_extension import BaseGeomExtension as BaseGeomExtension
from shapely.extension.model import Angle as Angle
from shapely.extension.model.interval import Interval as Interval
from shapely.extension.model.projection import ProjectionOnLine as ProjectionOnLine
from shapely.extension.strategy.bypassing_strategy import BaseBypassingStrategy as BaseBypassingStrategy
from shapely.extension.strategy.offset_strategy import BaseOffsetStrategy as BaseOffsetStrategy
from shapely.extension.typing import CoordType as CoordType, Num as Num
from shapely.extension.util.prolong import Prolong as Prolong
from shapely.geometry import Point as Point
from shapely.geometry.base import BaseGeometry as BaseGeometry
from typing import Callable


class LineStringExtension(BaseGeomExtension):
    def __getitem__(self, item): ...

    def substring(self, interval: Union[Tuple[Num, Num], Interval], absolute: bool = ...): ...

    def inverse(self) -> LineString: ...

    def start(self) -> Point: ...

    def end(self) -> Point: ...

    def prolong(self, absolute: bool = ...) -> Prolong: ...

    def bypass(self, geom: BaseGeometry, strategy: Optional[BaseBypassingStrategy] = ...) -> LineString: ...

    def offset(self, dist: Num, towards: Union[str, BaseGeometry] = ..., invert_coords: bool = ...,
               strategy: Optional[BaseOffsetStrategy] = ...) -> LineString: ...

    def is_parallel_to(self, other: LineString, angle_tol: Num = ...,
                       angle_strategy: Optional[Callable[[BaseGeometry], Angle]] = ...) -> bool: ...

    def is_perpendicular_to(self, other: LineString, angle_tol: Num = ...,
                            angle_strategy: Optional[Callable[[BaseGeometry], Angle]] = ...) -> bool: ...

    def is_collinear_to(self, other: LineString, angle_tol: Num = ...,
                        angle_strategy: Optional[Callable[[BaseGeometry], Angle]] = ...) -> bool: ...

    def is_straight(self, angle_tol: Num = ...) -> bool: ...

    def extend_to_merge(self, line: LineString, extent_dist: Num = ...) -> Optional[LineString]: ...

    def projection_by(self, geom_or_geoms: Union[BaseGeometry, Iterable[BaseGeometry]],
                      direction: Optional[Vector] = ..., out_of_geom: bool = ...) -> ProjectionOnLine: ...

    def projected_point(self, point_or_coord: Union[Point, CoordType]) -> Point: ...

    def perpendicular_line(self, point: Point, length: Num, position: str = ...) -> LineString: ...

    def tangent_line(self, point: Point, length: Num, position: str = ...) -> LineString: ...


from shapely.extension.extension.base_geom_extension import BaseGeomExtension as BaseGeomExtension
from shapely.extension.model.vector import Vector as Vector
from shapely.extension.strategy.decompose_strategy import BaseDecomposeStrategy as BaseDecomposeStrategy
from shapely.geometry import LineString as LineString, MultiPolygon as MultiPolygon, Polygon as Polygon
from typing import Iterable, Optional, Tuple, Union


class PolygonExtension(BaseGeomExtension):
    def edge_pair_with(self, poly_or_line: Union[Polygon, LineString],
                       decompose_strategy: Optional[BaseDecomposeStrategy] = ...) -> Iterable[
        Tuple[LineString, LineString]]: ...

    def has_edge_parallel_to(self, poly_or_line: Union[Polygon, LineString],
                             decompose_strategy: Optional[BaseDecomposeStrategy] = ...) -> bool: ...

    def has_edge_perpendicular_to(self, poly_or_line: Union[Polygon, LineString],
                                  decompose_strategy: Optional[BaseDecomposeStrategy] = ...): ...

    def has_edge_collinear_to(self, poly_or_line: Union[Polygon, LineString],
                              decompose_strategy: Optional[BaseDecomposeStrategy] = ...): ...

    def union(self, poly: Polygon, direction: Optional[Vector] = ..., dist_tol: float = ...) -> Union[
        Polygon, MultiPolygon]: ...


def ext_entry() -> Union[BaseGeomExtension, LineStringExtension, PolygonExtension]: ...
